<!DOCTYPE html>
<html>
<style>
	td, th
	{
	    border: 1px solid #dddddd;
	    text-align: left;
	    padding: 8px;
	}

	.frac
	{
	    display: inline-block;
	    position: relative;
	    vertical-align: middle;
	    letter-spacing: 0.001em;
	    text-align: center;
	}

	.frac > span
	{
	    display: block;
	    padding: 0.1em;
	}

	.frac span.bottom
	{
    	border-top: thin solid black;
	}

	.frac span.symbol
	{
	    display: none;
	}
</style>
<body>

<h1>Assignment 4: Petri Nets</h1>
<ul>
	<li>Rafael De Smet - 20131145</li>
	<li>Beno&#238;t-Philippe Fornoville - 20133299</li>
</ul>

This report shows the results of assignment 4.

<h1>Complete solution</h1>
<img src="report/railroad.png">

<h1>Files</h1>

In the folder you can find a few .xml files that contain each a different Petri Net. The file <a href="RailroadComplete.xml">RailroadComplete.xml</a> is the complete Petri Net, shown above. The file <a href="Railroad.xml">Railroad.xml</a> is the same net, but without the generators of the trains. The file <a href="simplifiedRailroad.xml">simplifiedRailroad.xml</a> is the simplified net, which is shown and discussed below.

<h1>Invariant analysis</h1>

For the complete invariant analysis generated by PIPE2, see <a href="report/invariantAnalysis.html">invariantAnalysis.html</a>.

<h2>Invariants:</h2>
<ol>
	<li>M(TrainGenerator1) = 1</li>
	<li>M(TrainGenerator2) = 1</li>
	<li>M(Pre) + M(Post) + M(Tick) = 1</li>
	<li>M(CapacityConstraint1) + M(CritialSection1) + M(Entrance1_segment) + M(Green1) = 1</li>
	<li>M(CriticalSection2) + M(Entrance2_segment) + M(CapacityConstraint2) + M(Green2) = 1</li>
	<li>M(SemaphoreClocked) + M(Semaphore) + M(CritialSection1) + M(CriticalSection2) + (CriticalSection3) + M(Green1) + M(Red1) = 1</li>
	<li>M(SemaphoreClocked) + M(Semaphore) + M(CritialSection1) + M(CriticalSection2) + M(CriticalSection3) + M(Green2) + M(Red2) = 1</li>
</ol>

<h3>Invariant 1 and 2</h3>
As mentioned in the name TrainGenerator1 is a generator place. It can create an infinite amount of trains for track1.<br>
TrainGenerator2: analoguous.

<h3>Invariant 3</h3>
The clock has a clock tick that can be in one of three phases: tick, pre or post.

<h3>Invariant 4 and 5</h3>
These 4 places keep track if there is a train in segment 1. If there is no train CapacityConstraint1 will be 1. When a train enters segment1 Entrance1_segment wil be 1 and CapacityConstraint1 will be 0. Then it waits for the semaphore to fire T1. CriticalSection1 will be active. TCrit1 will fire, which will lead to a green light (Green1). When the light is green the train can either leave the segment, which will put CapacityConstraint1 back to 1, or it can choose to stay, thus setting Entrance1_segment back to 1.<br>
Invariance5: analogous for segment 2.

<h3>Invariant 6 and 7</h3>
Invariant 6 and 7 express that we have a semaphore that can be used to enter one of the 3 critical sections.
Invariance6:
<ul>
	<li>
		CriticalSection1: activates Green1
	</li>
	<li>
		CriticalSection2: activates Red1
	</li>
	<li>
		CriticalSection2: activates Red1
	</li>
</ul>
Invariance7:
<ul>
	<li>
		CriticalSection1: activates Red2
	</li>
	<li>
		CriticalSection2: activates Green2
	</li>
	<li>
		CriticalSection2: activates Red2
	</li>
</ul>

<h1>Deadlock</h1>

PIPE tells us this net is deadlock free. To understand this intuitively we have to separate the graph into two cyclic graphs:
<br>
<ol>
	<li>
		The first cyclic graph is the one implementing the clock. It contains 3 places (Tick, Pre and Post) and 3 transitions (ClockTick, TClock1 and TClock2). It is easy to see that this graph is cyclic and doesn't contain a deadlock, if we remove the arc coming from the semaphore. The place called clock can then be seen as a counter.
	</li>
<br>
	<li>
		The second cyclic graph is more complicated, it contains all the other places and transitions, plus the TClock1 transition. This cycle has 3 phases:
		<ol>
			<li>At first we have a token in Semaphore.</li>
			<li>Then this token is given to the clocked token.</li>
			<li>The clocked token can then go to one of the 3 critical sections.
				<ul>
					<li>
						If we arrive at CriticalSection1, T1 must have fired, implying NewTrain1 had fired previously (and can't fire any more). We thus have that CapacityConstraint1 and Entrance1_segment are empty. We then enter Green1 and Red2, which gives the choice to either fire Train1Leaves or Train1DoesNotLeave. If Train1DoesNotLeave fires, we return the semaphore (and put CapacityConstraint1 to 1, meaning that entry1 is empty again). Otherwise Train1Train1DoesNotLeave is fired, this also returns the semaphore (and puts Entrance1_segment to 1, meaning that the train is still on the entry.)
					</li>
					<li>
						CriticalSection2: analogous
					</li>
					<li>
						If we arrrive in CriticalSection3, we have to active both red lights and eventually fire TCritical3, which returns the semaphore.
					</li>
				</ul>
			</li>
		</ol>
		In all cases the semaphore and the trainToken are returned correctly.
	</li>
</ol>
We can conclude that the graph is deadlock-free.

In order to reduce the size of the reachability graph which we need to analyse the net, we use a simplified version of the net, which you can see below. This version omits the clock and the generators for the train. We do this because these parts are not essential for the analysis.

<img src="report/simplifiedRailroad.png">

<h1>Reachability</h1>

Before we start with the complete analysis, we need to generate the reachability graph via the PIPE tool. You can see this graph here. Remember that this is the reachability graph of the simplified version.
<br>

<img src="report/reachabilitySimplifiedRailroad.png">

<h1>Boundedness</h1>

In this table you can find the boundedness of every state in the simplified net. The order is the same as used by PIPE to generate the reachability graph.<br>
<br>
<table>
	<tr>
		<th>Place</th>
		<th>Initial State</th>
		<th>Boundedness</th>
	</tr>
	<tr>
		<td>SemaphoreClocked</td>
		<td>0</td>
		<td>1-bounded = safe</td>
	</tr>
	<tr>
		<td>Semaphore</td>
		<td>1</td>
		<td>1-bounded = safe</td>
	</tr>
	<tr>
		<td>CriticalSection1</td>
		<td>0</td>
		<td>1-bounded = safe</td>
	</tr>
	<tr>
		<td>CriticalSection2</td>
		<td>0</td>
		<td>1-bounded = safe</td>
	</tr>
	<tr>
		<td>Entrance2_segment</td>
		<td>1</td>
		<td>1-bounded = safe</td>
	</tr>
	<tr>
		<td>exit_segment</td>
		<td>0</td>
		<td><b>2-bounded</b></td>
	</tr>
	<tr>
		<td>Entrance1_segment</td>
		<td>1</td>
		<td>1-bounded = safe</td>
	</tr>
	<tr>
		<td>CriticalSection3</td>
		<td>0</td>
		<td>1-bounded = safe</td>
	</tr>
	<tr>
		<td>Green1</td>
		<td>0</td>
		<td>1-bounded = safe</td>
	</tr>
	<tr>
		<td>Red1</td>
		<td>0</td>
		<td>1-bounded = safe</td>
	</tr>
	<tr>
		<td>Green2</td>
		<td>0</td>
		<td>1-bounded = safe</td>
	</tr>
	<tr>
		<td>Red2</td>
		<td>0</td>
		<td>1-bounded = safe</td>
	</tr>
</table>
<br>
This shows that the net is 2-bounded but not safe.

<h1>Liveness</h1>

The liveness is computed for every transition. Again, we work with the simplified net and its reachability graph.

<br>
<br>
<table>
	<tr>
		<th>Transition</th>
		<th colspan="5">Liveness</th>
	</tr>
	<tr>
		<td>TTickAndSemaphore</td>
		<td>L0-live: X</td>
		<td>L1-live: &#10004;</td>
		<td>L2-live: &#10004; with k = 4</td>
		<td>L3-live: &#10004; in loop: S0 &rarr; S1 &rarr; S2 &rarr; S5 &rarr; S0</td>
		<td>L4-live: X</td>
	</tr>
	<tr>
		<td>TCrit1Pre</td>
		<td>L0-live: X</td>
		<td>L1-live: &#10004;</td>
		<td>L2-live: &#10004; with k = 2</td>
		<td>L3-live: &#10004; in loop: S1 &rarr; S3 &rarr; S6 &rarr; S0 &rarr; S1</td>
		<td>L4-live: X</td>
	</tr>
	<tr>
		<td>TCrit2Pre</td>
		<td>L0-live: X</td>
		<td>L1-live: &#10004;</td>
		<td>L2-live: &#10004; with k = 2</td>
		<td>L3-live: &#10004; in loop: S1 &rarr; S4 &rarr; S7 &rarr; S0 &rarr; S1</td>
		<td>L4-live: X</td>
	</tr>
	<tr>
		<td>TCrit3Pre</td>
		<td>L0-live: X</td>
		<td>L1-live: &#10004;</td>
		<td>L2-live: &#10004; with k = 4</td>
		<td>L3-live: &#10004; in loop: S1 &rarr; S2 &rarr; S5 &rarr; S0 &rarr; S1</td>
		<td>L4-live: X</td>
	</tr>
	<tr>
		<td>TCrit1Post</td>
		<td>L0-live: X</td>
		<td>L1-live: &#10004;</td>
		<td>L2-live: &#10004; with k = 2</td>
		<td>L3-live: &#10004; in loop: S3 &rarr; S6 &rarr; S0 &rarr; S1 &rarr; S3</td>
		<td>L4-live: X</td>
	</tr>
	<tr>
		<td>TCrit2Post</td>
		<td>L0-live: X</td>
		<td>L1-live: &#10004;</td>
		<td>L2-live: &#10004; with k = 2</td>
		<td>L3-live: &#10004; in loop: S4 &rarr; S7 &rarr; S0 &rarr; S1 &rarr; S4</td>
		<td>L4-live: X</td>
	</tr>
	<tr>
		<td>TCrit3Post</td>
		<td>L0-live: X</td>
		<td>L1-live: &#10004;</td>
		<td>L2-live: &#10004; with k : 4</td>
		<td>L3-live: &#10004; in loop: S2 &rarr; S5 &rarr; S0 &rarr; S1 &rarr; S2</td>
		<td>L4-live: X</td>
	</tr>
	<tr>
		<td>Train1DoesNotLeave</td>
		<td>L0-live: X</td>
		<td>L1-live: &#10004;</td>
		<td>L2-live: &#10004; with k = 2</td>
		<td>L3-live: &#10004; in loop: S6 &rarr; S0 &rarr; S1 &rarr; S3 &rarr; S6</td>
		<td>L4-live: X</td>
	</tr>
	<tr>
		<td>Train1Leaves</td>
		<td>L0-live: X</td>
		<td>L1-live: &#10004;</td>
		<td>L2-live: &#10004; with k = 2</td>
		<td>L3-live: X</td>
		<td>L4-live: X</td>
	</tr>
	<tr>
		<td>TCritical3</td>
		<td>L0-live: X</td>
		<td>L1-live: &#10004;</td>
		<td>L2-live: &#10004; with k = 3</td>
		<td>L3-live: &#10004; in loop: S5 &rarr; S0 &rarr; S1 &rarr; S2 &rarr; S5</td>
		<td>L4-live: X</td>
	</tr>
	<tr>
		<td>Train2Leaves</td>
		<td>L0-live: X</td>
		<td>L1-live: &#10004;</td>
		<td>L2-live: &#10004; with k = 2</td>
		<td>L3-live: X</td>
		<td>L4-live: X</td>
	</tr>
	<tr>
		<td>Train2DoesNotLeave</td>
		<td>L0-live: X</td>
		<td>L1-live: &#10004;</td>
		<td>L2-live: &#10004; with k = 2</td>
		<td>L3-live: &#10004; in loop: S7 &rarr; S0 &rarr; S1 &rarr; S4 &rarr; S7 </td>
		<td>L4-live: X</td>
	</tr>
</table>
<br>

It is clear that there are no dead transitions and every transition is at least L2-live.

<h1>Persistence</h1>

There are several combinations of transitions that are enabled at the same time and which can lead to non-determinism. What follows is a list of these combinations and an explanation of why they are (non-)deterministic.

<ol>
	<li>
		The set of transitions {TCrit1Pre, TCrit2Pre, TCrit3Pre} is enabled at the same time. This happens when the semaphoreClocked place has a token. This means that the semaphore tells the net to access a critical section. Which sections this is, is determined by the firig of one of the three transitions. When we fire any of these three transitions, the other two are disabled. This is what we would expect because the semaphore allows only one critical section to be active at a time. So we can say that these transitions are non persistent.
	</li>
	<li>
		The set of transitions {Train1DoesNotLeave, Train1Leaves} is enabled at the same time. This happens when the critical section 1 has been executed (we have seen TCrit1Post). Here the train on segment 1 makes a choice between going on the exit segment (which is now allowed) and staying on segment 1. When we fire either one of these two transitions, the other one is enabled, which is only logical because a train cannot leave its segment and stay on it at the same time. So we can say that these transitions are non persistent.
	</li>
	<li>
		The set of transitions {Train2DoesNotLeave, Train2Leaves} is enabled at the same time, after the execution of critical section 2. The same logic applies here as in the previous case. So we can say that these transitions are non persistent.
	</li>
	<li>
		When we add the transition TClock2 to the first set of transitions {TCrit1Pre, TCrit2Pre, TCrit3Pre}, we have a new situation. The four transitions are at one point enabled at the same time. When we fire TClock2, the other three transitions are still enabled. But when we fire any of the three others (not TClock2), let's say TCrit3Pre, TCrit1Pre and TCrit2Pre are disabled while TClock2 is still enabled.
	</li>
	<li>
		The same situation is seen in the other two cases (number 2 and 3). When we add TClock2 to {Train1DoesNotLeave, Train1Leaves} we see that the firing of TClock2 does not affect the two other transitions, but the firing of any of these two transitions still affects the other one. When we add TClock2 to {Train2DoesNotLeave, Train2Leaves}, we see the same behaviour.
	</li>
</ol>

We can conclude that this net is not persistent.

<h1>Conclusion: Can two trains crash?</h1>
Invariants 6 and 7 tell us we have maximum one train at the time on each incoming track. By using the mutual exclusion technique for the lights, we can't have two green lights at the same time, thus we can't have collisions. The inhibitor arcs coming from exit_segment are an extra insurance that we can't have two trains on exit_segment.

</body>

</html>