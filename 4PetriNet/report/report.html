<!DOCTYPE html>
<html>
<style>
	td, th 
	{
	    border: 1px solid #dddddd;
	    text-align: left;
	    padding: 8px;
	}

	.frac 
	{
	    display: inline-block;
	    position: relative;
	    vertical-align: middle;
	    letter-spacing: 0.001em;
	    text-align: center;
	}

	.frac > span 
	{
	    display: block;
	    padding: 0.1em;
	}

	.frac span.bottom 
	{
    	border-top: thin solid black;
	}

	.frac span.symbol 
	{
	    display: none;
	} 
</style>
<body>

<h1>Assignment 4: Petri Nets</h1>
<ul>
	<li>Rafael De Smet - 20131145</li>
	<li>Beno&#238;t-Philippe Fornoville - 20133299</li>
</ul>

This report shows the results of assignment 4.

<h1>Complete solution</h1>
<img src="railroad.png">

<h1>Invariant analysis</h1>

For the complete invariant analysis generated by PIPE2, see <a href="invariantAnalysis.html">invariantAnalysis.html</a>.

<h2>Invariants:</h2>
<ol>
	<li>M(TrainGenerator1) = 1</li>
	<li>M(TrainGenerator2) = 1</li>
	<li>M(Pre) + M(Post) + M(Tick) = 1</li>
	<li>M(CapacityConstraint1) + M(CritialSection1) + M(Entrance1_segment) + M(Green1) = 1</li>
	<li>M(CriticalSection2) + M(Entrance2_segment) + M(CapacityConstraint2) + M(Green2) = 1</li>
	<li>M(SemaphoreClocked) + M(Semaphore) + M(CritialSection1) + M(CriticalSection2) + (CriticalSection3) + M(Green1) + M(Red1) = 1</li>
	<li>M(SemaphoreClocked) + M(Semaphore) + M(CritialSection1) + M(CriticalSection2) + M(CriticalSection3) + M(Green2) + M(Red2) = 1</li>
</ol>

<h3>Invariant 1 and 2</h3>
As mentioned in the name TrainGenerator1 is a generator place. It can create an infinite amount of trains for track1.<br>
Analogously TrainGenerator2 can create trains for the second incoming segement. 

<h3>Invariant 3</h3>
The clock has a clock tick that can be in one of three phases: tick, pre or post.

<h3>Invariant 4 and 5</h3>
The first incoming segment can contain maximum one train. If there is no train CapacityConstraint1 will be 1. When a train enters segment1 Entrance1_segment wil be 1 and CapacityConstraint1 will be 0. Then it waits for the semaphore. When the train receives the semaphore it can enter CriticalSection1, which will lead to a green light (Green1). When the light is green the train can either leave the segment, which will put CapacityConstraint1 back to 1, or it can choose to stay, thus setting Entrance1_segment back to 1.
Segment2 works analogously.

<h3>Invariant 6 and 7</h3>
Invariant 6 and 7 express that we have a semaphore that can be used to enter one of the 3 critical sections.
<ul>
	<li>
		CriticalSection1: will set Green1 to 1 and Red2 to 0.
	</li>
	<li>
		CriticalSection2: <b>TODO</b>
	</li>
</ul>

In order to reduce the size of the reachabilityy graph which we need to analyse the net, we use a simplified version of the net, which you can see below. This version omits the clock and the generators for the train. We do this because these parts are not essential for the analysis. They are important because they allow concurrency and fairness. Later we will discuss fairness.

<img src="simplifiedRailroad.png">

<h1>Reachability</h1>

Before we start with the complete analysis, we need to generate the reachability graph via the PIPE tool. You can see this graph here. Remember that this is the reachability graph of the simplified version.
<br>

<img src="reachabilitySimplifiedRailRoad.png">

<h1>Boundedness</h1>

In this table you can find the boundedness of every state in the simplified net. The order is the same as used by PIPE to generate the reachability graph.<br>
<br>
<table>
	<tr>
		<th>Place</th>
		<th>Initial State</th>
		<th>Boundedness</th>
	</tr>
	<tr>
		<td>SemaphoreClocked</td>
		<td>0</td>
		<td>1-bounded = safe</td>
	</tr>
	<tr>
		<td>Semaphore</td>
		<td>1</td>
		<td>1-bounded = safe</td>
	</tr>
	<tr>
		<td>CriticalSection1</td>
		<td>0</td>
		<td>1-bounded = safe</td>
	</tr>
	<tr>
		<td>CriticalSection2</td>
		<td>0</td>
		<td>1-bounded = safe</td>
	</tr>
	<tr>
		<td>Entrance2_segment</td>
		<td>1</td>
		<td>1-bounded = safe</td>
	</tr>
	<tr>
		<td>exit_segment</td>
		<td>0</td>
		<td><b>2-bounded</b></td>
	</tr>
	<tr>
		<td>Entrance1_segment</td>
		<td>1</td>
		<td>1-bounded = safe</td>
	</tr>
	<tr>
		<td>CriticalSection3</td>
		<td>0</td>
		<td>1-bounded = safe</td>
	</tr>
	<tr>
		<td>Green1</td>
		<td>0</td>
		<td>1-bounded = safe</td>
	</tr>
	<tr>
		<td>Red1</td>
		<td>0</td>
		<td>1-bounded = safe</td>
	</tr>
	<tr>
		<td>Green2</td>
		<td>0</td>
		<td>1-bounded = safe</td>
	</tr>
	<tr>
		<td>Red2</td>
		<td>0</td>
		<td>1-bounded = safe</td>
	</tr>
</table>
<br>
This shows that the net is 2-bounded but not safe.

<h1>Deadlock</h1>

PIPE tells us this net is deadlock free. <b>TODO</b>

<h1>Liveness</h1>

The liveness is computed for every transition. Again, we work with the simplified net and its reachability graph.

<b>TODO check alle L3 nog eens</b>
<br>
<br>
<table>
	<tr>
		<th>Transition</th>
		<th colspan="5">Liveness</th>
	</tr>
	<tr>
		<td>TTickAndSemaphore</td>
		<td>L0-live: X</td>
		<td>L1-live: &#10004;</td>
		<td>L2-live: &#10004; with k = 4</td>
		<td>L3-live: &#10004; in loop: S0 &rarr; S1 &rarr; S2 &rarr; S5 &rarr; S0</td> 
		<td>L4-live: X</td>
	</tr>
	<tr>
		<td>TCrit1Pre</td>
		<td>L0-live: X</td>
		<td>L1-live: &#10004;</td>
		<td>L2-live: &#10004; with k = 2</td>
		<td>L3-live: &#10004; in loop: S1 &rarr; S3 &rarr; S6 &rarr; S0 &rarr; S1</td>
		<td>L4-live: X</td>
	</tr>
	<tr>
		<td>TCrit2Pre</td>
		<td>L0-live: X</td>
		<td>L1-live: &#10004;</td>
		<td>L2-live: &#10004; with k = 2</td>
		<td>L3-live: &#10004; in loop: S1 &rarr; S4 &rarr; S7 &rarr; S0 &rarr; S1</td>
		<td>L4-live: X</td>
	</tr>
	<tr>
		<td>TCrit3Pre</td>
		<td>L0-live: X</td>
		<td>L1-live: &#10004;</td>
		<td>L2-live: &#10004; with k = 4</td>
		<td>L3-live: &#10004; in loop: S1 &rarr; S2 &rarr; S5 &rarr; S0 &rarr; S1</td>
		<td>L4-live: X</td>
	</tr>
	<tr>
		<td>TCrit1Post</td>
		<td>L0-live: X</td>
		<td>L1-live: &#10004;</td>
		<td>L2-live: &#10004; with k = 2</td>
		<td>L3-live: &#10004; in loop: S3 &rarr; S6 &rarr; S0 &rarr; S1 &rarr; S3</td>
		<td>L4-live: X</td>
	</tr>
	<tr>
		<td>TCrit2Post</td>
		<td>L0-live: X</td>
		<td>L1-live: &#10004;</td>
		<td>L2-live: &#10004; with k = 2</td>
		<td>L3-live: &#10004; in loop: S4 &rarr; S7 &rarr; S0 &rarr; S1 &rarr; S4</td>
		<td>L4-live: X</td>
	</tr>
	<tr>
		<td>TCrit3Post</td>
		<td>L0-live: X</td>
		<td>L1-live: &#10004;</td>
		<td>L2-live: &#10004; with k : 4</td>
		<td>L3-live: &#10004; in loop: S2 &rarr; S5 &rarr; S0 &rarr; S1 &rarr; S2</td>
		<td>L4-live: X</td>
	</tr>
	<tr>
		<td>Train1DoesNotLeave</td>
		<td>L0-live: X</td>
		<td>L1-live: &#10004;</td>
		<td>L2-live: &#10004; with k = 2</td>
		<td>L3-live: &#10004; in loop: S6 &rarr; S0 &rarr; S1 &rarr; S3 &rarr; S6</td>
		<td>L4-live: X</td>
	</tr>
	<tr>
		<td>Train1Leaves</td>
		<td>L0-live: X</td>
		<td>L1-live: &#10004;</td>
		<td>L2-live: &#10004; with k = 2</td>
		<td>L3-live: X</td>
		<td>L4-live: X</td>
	</tr>
	<tr>
		<td>TCritical3</td>
		<td>L0-live: X</td>
		<td>L1-live: &#10004;</td>
		<td>L2-live: &#10004; with k = 3</td>
		<td>L3-live: &#10004; in loop: S5 &rarr; S0 &rarr; S1 &rarr; S2 &rarr; S5</td>
		<td>L4-live: X</td>
	</tr>
	<tr>
		<td>Train2Leaves</td>
		<td>L0-live: X</td>
		<td>L1-live: &#10004;</td>
		<td>L2-live: &#10004; with k = 2</td>
		<td>L3-live: X</td>
		<td>L4-live: X</td>
	</tr>
	<tr>
		<td>Train2DoesNotLeave</td>
		<td>L0-live: X</td>
		<td>L1-live: &#10004;</td>
		<td>L2-live: &#10004; with k = 2</td>
		<td>L3-live: &#10004; in loop: S7 &rarr; S0 &rarr; S1 &rarr; S4 &rarr; S7 </td>
		<td>L4-live: X</td>
	</tr>
</table>
<br>

It is clear that there are no dead transitions and every transition is at least L2-live.

<h1>Persistence</h1>

<b>TODO</b>

<h1>Conclusion: Can two trains crash?</h1>

<b>TODO</b>